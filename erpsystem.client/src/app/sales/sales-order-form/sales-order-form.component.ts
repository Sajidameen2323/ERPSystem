import { Component, OnInit, signal, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { RouterModule, ActivatedRoute, Router } from '@angular/router';
import { ReactiveFormsModule, FormBuilder, FormGroup, FormArray, Validators } from '@angular/forms';
import { finalize, debounceTime, distinctUntilChanged, switchMap } from 'rxjs';

// Lucide Icons
import { LucideAngularModule, ArrowLeft, Save, Plus, Trash2, Package, Search, Users, ShoppingCart } from 'lucide-angular';

// Services and Models
import { SalesOrderService } from '../services/sales-order.service';
import { CustomerService } from '../services/customer.service';
import { ProductService } from '../../shared/services/product.service';
import { SalesOrder, SalesOrderCreateRequest, SalesOrderUpdateRequest } from '../models/sales-order.model';
import { Customer } from '../models/customer.model';
import { Product } from '../../shared/models/product.interface';

// Shared Components
import { LoadingSpinnerComponent } from '../../shared/components/loading-spinner/loading-spinner.component';

@Component({
  selector: 'app-sales-order-form',
  standalone: true,
  imports: [
    CommonModule, 
    RouterModule, 
    ReactiveFormsModule,
    LucideAngularModule,
    LoadingSpinnerComponent
  ],
  templateUrl: './sales-order-form.component.html',
  styleUrls: ['./sales-order-form.component.css']
})
export class SalesOrderFormComponent implements OnInit {
  private readonly salesOrderService = inject(SalesOrderService);
  private readonly customerService = inject(CustomerService);
  private readonly productService = inject(ProductService);
  private readonly route = inject(ActivatedRoute);
  private readonly router = inject(Router);
  private readonly fb = inject(FormBuilder);

  // Icons
  readonly ArrowLeftIcon = ArrowLeft;
  readonly SaveIcon = Save;
  readonly PlusIcon = Plus;
  readonly Trash2Icon = Trash2;
  readonly PackageIcon = Package;
  readonly SearchIcon = Search;
  readonly UsersIcon = Users;
  readonly ShoppingCartIcon = ShoppingCart;

  // Signals
  salesOrder = signal<SalesOrder | null>(null);
  customers = signal<Customer[]>([]);
  products = signal<Product[]>([]);
  filteredCustomers = signal<Customer[]>([]);
  filteredProducts = signal<{[key: number]: Product[]}>({});
  loading = signal(false);
  saving = signal(false);
  error = signal<string | null>(null);
  isEditMode = signal(false);
  orderId = signal<string>('');
  
  // Search states
  customerSearchTerm = signal('');
  productSearchTerms = signal<{[key: number]: string}>({});
  showCustomerDropdown = signal(false);
  showProductDropdowns = signal<{[key: number]: boolean}>({});
  selectedProducts = signal<{[key: number]: Product | null}>({});

  // Form
  salesOrderForm!: FormGroup;

  ngOnInit(): void {
    this.initializeForm();
    this.loadCustomers();
    this.loadProducts();

    const id = this.route.snapshot.paramMap.get('id');
    if (id) {
      this.isEditMode.set(true);
      this.orderId.set(id);
      this.loadSalesOrder(id);
    } else {
      // Add initial order item for new orders
      this.addOrderItem();
    }
  }

  /**
   * Initialize the form
   */
  initializeForm(): void {
    this.salesOrderForm = this.fb.group({
      customerId: ['', [Validators.required]],
      customerSearch: [''],
      orderedByUserId: ['current-user-id', [Validators.required]], // TODO: Get from auth service
      orderNotes: [''],
      // referenceNumber removed - now auto-generated by backend
      orderItems: this.fb.array([])
    });

    // Setup customer search
    this.salesOrderForm.get('customerSearch')?.valueChanges.pipe(
      debounceTime(300),
      distinctUntilChanged()
    ).subscribe(searchTerm => {
      this.customerSearchTerm.set(searchTerm);
      this.filterCustomers(searchTerm);
      this.showCustomerDropdown.set(searchTerm.length > 0);
    });
  }

  /**
   * Filter customers based on search term
   */
  filterCustomers(searchTerm: string): void {
    if (!searchTerm) {
      this.filteredCustomers.set([]);
      return;
    }
    
    const filtered = this.customers().filter(customer => 
      customer.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      (customer.email && customer.email.toLowerCase().includes(searchTerm.toLowerCase()))
    );
    this.filteredCustomers.set(filtered);
  }

  /**
   * Filter products based on search term for specific item
   */
  filterProducts(searchTerm: string, itemIndex: number): void {
    if (!searchTerm) {
      const filtered = this.filteredProducts();
      filtered[itemIndex] = [];
      this.filteredProducts.set({ ...filtered });
      return;
    }
    
    const products = this.products().filter(product => 
      product.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      product.sku.toLowerCase().includes(searchTerm.toLowerCase()) ||
      (product.description && product.description.toLowerCase().includes(searchTerm.toLowerCase()))
    );
    
    const filtered = this.filteredProducts();
    filtered[itemIndex] = products;
    this.filteredProducts.set({ ...filtered });
    
    // Update dropdown visibility
    const dropdowns = this.showProductDropdowns();
    dropdowns[itemIndex] = searchTerm.length > 0 && products.length > 0;
    this.showProductDropdowns.set({ ...dropdowns });
  }

  /**
   * Select a customer
   */
  selectCustomer(customer: Customer): void {
    this.salesOrderForm.patchValue({
      customerId: customer.id,
      customerSearch: customer.name
    });
    this.showCustomerDropdown.set(false);
  }

  /**
   * Select a product for specific item
   */
  selectProduct(product: Product, itemIndex: number): void {
    // Prevent selecting out of stock products
    if (this.isProductOutOfStock(product)) {
      return;
    }
    
    const item = this.orderItems.at(itemIndex);
    item.patchValue({
      productId: product.id,
      productSearch: `${product.name} (${product.sku})`,
      unitPrice: product.unitPrice,
      productName: product.name,
      productSku: product.sku
    });
    
    // Store selected product for validation
    const selected = this.selectedProducts();
    selected[itemIndex] = product;
    this.selectedProducts.set({ ...selected });
    
    // Hide dropdown
    const dropdowns = this.showProductDropdowns();
    dropdowns[itemIndex] = false;
    this.showProductDropdowns.set({ ...dropdowns });
    
    // Clear filtered products for this item
    const filtered = this.filteredProducts();
    filtered[itemIndex] = [];
    this.filteredProducts.set({ ...filtered });
  }

  /**
   * Get order items form array
   */
  get orderItems(): FormArray {
    return this.salesOrderForm.get('orderItems') as FormArray;
  }

  /**
   * Create order item form group
   */
  createOrderItemGroup(): FormGroup {
    return this.fb.group({
      productId: ['', [Validators.required]],
      productSearch: [''],
      productName: [''],
      productSku: [''],
      quantity: [1, [Validators.required, Validators.min(1)]],
      unitPrice: [0, [Validators.required, Validators.min(0.01)]],
      notes: ['']
    });
  }

  /**
   * Get available stock for a product in an order item
   */
  getAvailableStock(itemIndex: number): number {
    const selected = this.selectedProducts();
    const product = selected[itemIndex];
    return product ? product.currentStock : 0;
  }

  /**
   * Check if quantity exceeds available stock
   */
  isQuantityExceedsStock(itemIndex: number): boolean {
    const item = this.orderItems.at(itemIndex);
    const quantity = item.get('quantity')?.value || 0;
    const availableStock = this.getAvailableStock(itemIndex);
    return quantity > availableStock;
  }

  /**
   * Check if product is low stock
   */
  isProductLowStock(product: Product): boolean {
    return product.isLowStock || (product.minimumStock !== undefined && product.currentStock <= product.minimumStock);
  }

  /**
   * Check if product is out of stock
   */
  isProductOutOfStock(product: Product): boolean {
    return product.currentStock <= 0;
  }

  /**
   * Add new order item
   */
  addOrderItem(): void {
    const newIndex = this.orderItems.length;
    const newItem = this.createOrderItemGroup();
    
    // Setup product search for this item
    newItem.get('productSearch')?.valueChanges.pipe(
      debounceTime(300),
      distinctUntilChanged()
    ).subscribe(searchTerm => {
      const searchTerms = this.productSearchTerms();
      searchTerms[newIndex] = searchTerm;
      this.productSearchTerms.set({ ...searchTerms });
      this.filterProducts(searchTerm, newIndex);
    });
    
    this.orderItems.push(newItem);
  }

  /**
   * Remove order item
   */
  removeOrderItem(index: number): void {
    if (this.orderItems.length > 1) {
      this.orderItems.removeAt(index);
      
      // Clean up dropdown state
      const dropdowns = this.showProductDropdowns();
      delete dropdowns[index];
      this.showProductDropdowns.set({ ...dropdowns });
      
      const searchTerms = this.productSearchTerms();
      delete searchTerms[index];
      this.productSearchTerms.set({ ...searchTerms });
      
      const selected = this.selectedProducts();
      delete selected[index];
      this.selectedProducts.set({ ...selected });
      
      const filtered = this.filteredProducts();
      delete filtered[index];
      this.filteredProducts.set({ ...filtered });
    }
  }

  /**
   * Load customers for dropdown
   */
  loadCustomers(): void {
    this.customerService.getCustomers({ pageSize: 1000 })
      .subscribe({
        next: (result) => {
          if (result.isSuccess && result.data) {
            this.customers.set(result.data.items.filter(c => !c.isDeleted));
          }
        },
        error: (error) => {
          console.error('Error loading customers:', error);
        }
      });
  }

  /**
   * Load products for dropdown
   */
  loadProducts(): void {
    this.productService.getProducts({ 
      page: 1, 
      pageSize: 1000, 
      includeInactive: false 
    }).subscribe({
      next: (result) => {
        this.products.set(result.items.filter(p => !p.isDeleted));
      },
      error: (error) => {
        console.error('Error loading products:', error);
      }
    });
  }

  /**
   * Load sales order for editing
   */
  loadSalesOrder(id: string): void {
    this.loading.set(true);
    this.error.set(null);

    this.salesOrderService.getSalesOrderById(id)
      .pipe(
        finalize(() => this.loading.set(false))
      )
      .subscribe({
        next: (order) => {
          this.salesOrder.set(order);
          this.populateForm(order);
        },
        error: (error) => {
          console.error('Error loading sales order:', error);
          this.error.set('Failed to load sales order. Please try again.');
        }
      });
  }

  /**
   * Populate form with sales order data
   */
  populateForm(order: SalesOrder): void {
    // Find customer for display
    const customer = this.customers().find(c => c.id === order.customerId);
    
    this.salesOrderForm.patchValue({
      customerId: order.customerId,
      customerSearch: customer ? customer.name : '',
      orderedByUserId: order.orderedByUserId,
      orderNotes: order.orderNotes
      // referenceNumber removed from form - it's display-only now
    });

    // Clear existing order items
    while (this.orderItems.length !== 0) {
      this.orderItems.removeAt(0);
    }

    // Add order items
    order.orderItems.forEach((item, index) => {
      const product = this.products().find(p => p.id === item.productId);
      const itemGroup = this.createOrderItemGroup();
      
      itemGroup.patchValue({
        productId: item.productId,
        productSearch: product ? `${product.name} (${product.sku})` : '',
        productName: product?.name || '',
        productSku: product?.sku || '',
        quantity: item.quantity,
        unitPrice: item.unitPriceAtTimeOfOrder,
        notes: item.notes
      });
      
      // Store selected product for validation
      if (product) {
        const selected = this.selectedProducts();
        selected[index] = product;
        this.selectedProducts.set({ ...selected });
      }
      
      // Setup product search for this item
      itemGroup.get('productSearch')?.valueChanges.pipe(
        debounceTime(300),
        distinctUntilChanged()
      ).subscribe(searchTerm => {
        const searchTerms = this.productSearchTerms();
        searchTerms[index] = searchTerm;
        this.productSearchTerms.set({ ...searchTerms });
        this.filterProducts(searchTerm, index);
      });
      
      this.orderItems.push(itemGroup);
    });
  }

  /**
   * Submit form
   */
  onSubmit(): void {
    if (this.isFormValid()) {
      if (this.isEditMode()) {
        this.updateSalesOrder();
      } else {
        this.createSalesOrder();
      }
    } else {
      this.markFormGroupTouched(this.salesOrderForm);
      
      // Show specific error for stock validation
      let hasStockErrors = false;
      for (let i = 0; i < this.orderItems.length; i++) {
        if (this.isQuantityExceedsStock(i)) {
          hasStockErrors = true;
          break;
        }
      }
      
      if (hasStockErrors) {
        this.error.set('Please check quantity limits for all items. Some quantities exceed available stock.');
      }
    }
  }

  /**
   * Create new sales order
   */
  createSalesOrder(): void {
    this.saving.set(true);
    this.error.set(null);

    const formValue = this.salesOrderForm.value;
    const createRequest: SalesOrderCreateRequest = {
      customerId: formValue.customerId,
      orderedByUserId: formValue.orderedByUserId,
      orderNotes: formValue.orderNotes,
      // referenceNumber removed - now auto-generated by backend
      orderItems: formValue.orderItems.map((item: any) => ({
        productId: item.productId,
        quantity: item.quantity,
        unitPrice: item.unitPrice,
        notes: item.notes
      }))
    };

    this.salesOrderService.createSalesOrder(createRequest)
      .pipe(finalize(() => this.saving.set(false)))
      .subscribe({
        next: (order) => {
          this.router.navigate(['/sales/orders', order.id]);
        },
        error: (error) => {
          console.error('Error creating sales order:', error);
          this.error.set('Failed to create sales order. Please try again.');
        }
      });
  }

  /**
   * Update sales order
   */
  updateSalesOrder(): void {
    this.saving.set(true);
    this.error.set(null);

    const formValue = this.salesOrderForm.value;
    const updateRequest: SalesOrderUpdateRequest = {
      orderNotes: formValue.orderNotes,
      // referenceNumber kept for updates (display only, not editable)
      referenceNumber: formValue.referenceNumber,
      orderItems: formValue.orderItems.map((item: any) => ({
        productId: item.productId,
        quantity: item.quantity,
        unitPrice: item.unitPrice,
        notes: item.notes
      }))
    };

    this.salesOrderService.updateSalesOrder(this.orderId(), updateRequest)
      .pipe(finalize(() => this.saving.set(false)))
      .subscribe({
        next: (order) => {
          this.router.navigate(['/sales/orders', order.id]);
        },
        error: (error) => {
          console.error('Error updating sales order:', error);
          this.error.set('Failed to update sales order. Please try again.');
        }
      });
  }

  /**
   * Navigate back
   */
  goBack(): void {
    if (this.isEditMode()) {
      this.router.navigate(['/sales/orders', this.orderId()]);
    } else {
      this.router.navigate(['/sales/orders']);
    }
  }

  /**
   * Mark all fields in form group as touched
   */
  private markFormGroupTouched(formGroup: FormGroup): void {
    Object.keys(formGroup.controls).forEach(key => {
      const control = formGroup.get(key);
      control?.markAsTouched();

      if (control instanceof FormGroup) {
        this.markFormGroupTouched(control);
      } else if (control instanceof FormArray) {
        control.controls.forEach(arrayControl => {
          if (arrayControl instanceof FormGroup) {
            this.markFormGroupTouched(arrayControl);
          }
        });
      }
    });
  }

  /**
   * Get form control error message
   */
  getFieldError(fieldName: string, itemIndex?: number): string {
    let control;
    
    if (itemIndex !== undefined) {
      const item = this.orderItems.at(itemIndex);
      control = item?.get(fieldName);
    } else {
      control = this.salesOrderForm.get(fieldName);
    }
    
    if (control?.errors && control.touched) {
      if (control.errors['required']) {
        return `${fieldName} is required`;
      }
      if (control.errors['min']) {
        return `${fieldName} must be greater than ${control.errors['min'].min}`;
      }
    }
    
    // Check for stock validation
    if (fieldName === 'quantity' && itemIndex !== undefined && this.isQuantityExceedsStock(itemIndex)) {
      const availableStock = this.getAvailableStock(itemIndex);
      return `Only ${availableStock} units available in stock`;
    }
    
    return '';
  }

  /**
   * Check if field has errors
   */
  hasFieldError(fieldName: string, itemIndex?: number): boolean {
    let control;
    
    if (itemIndex !== undefined) {
      const item = this.orderItems.at(itemIndex);
      control = item?.get(fieldName);
    } else {
      control = this.salesOrderForm.get(fieldName);
    }
    
    const hasControlError = !!(control && control.invalid && (control.dirty || control.touched));
    
    // Check for stock validation
    if (fieldName === 'quantity' && itemIndex !== undefined) {
      return hasControlError || this.isQuantityExceedsStock(itemIndex);
    }
    
    return hasControlError;
  }

  /**
   * Check if form is valid
   */
  isFormValid(): boolean {
    let hasStockErrors = false;
    
    // Check for stock validation errors
    for (let i = 0; i < this.orderItems.length; i++) {
      if (this.isQuantityExceedsStock(i)) {
        hasStockErrors = true;
        break;
      }
    }
    
    return this.salesOrderForm.valid && !hasStockErrors;
  }

  /**
   * Clear product search and selection for an item
   */
  clearProductSelection(itemIndex: number): void {
    const item = this.orderItems.at(itemIndex);
    item.patchValue({
      productId: '',
      productSearch: '',
      productName: '',
      productSku: '',
      unitPrice: 0
    });
    
    // Clear selected product
    const selected = this.selectedProducts();
    selected[itemIndex] = null;
    this.selectedProducts.set({ ...selected });
    
    // Hide dropdown
    const dropdowns = this.showProductDropdowns();
    dropdowns[itemIndex] = false;
    this.showProductDropdowns.set({ ...dropdowns });
  }

  /**
   * Handle product search input focus
   */
  onProductSearchFocus(itemIndex: number): void {
    const searchTerm = this.orderItems.at(itemIndex).get('productSearch')?.value || '';
    if (searchTerm.length > 0) {
      this.filterProducts(searchTerm, itemIndex);
    }
  }

  /**
   * Handle product search input blur (with delay to allow selection)
   */
  onProductSearchBlur(itemIndex: number): void {
    setTimeout(() => {
      const dropdowns = this.showProductDropdowns();
      dropdowns[itemIndex] = false;
      this.showProductDropdowns.set({ ...dropdowns });
    }, 200);
  }

  /**
   * Calculate line total for an order item
   */
  calculateLineTotal(index: number): number {
    const item = this.orderItems.at(index);
    const quantity = item.get('quantity')?.value || 0;
    const unitPrice = item.get('unitPrice')?.value || 0;
    return quantity * unitPrice;
  }

  /**
   * Calculate order total
   */
  calculateOrderTotal(): number {
    let total = 0;
    for (let i = 0; i < this.orderItems.length; i++) {
      total += this.calculateLineTotal(i);
    }
    return total;
  }

  /**
   * Format currency
   */
  formatCurrency(amount: number): string {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(amount);
  }
}
